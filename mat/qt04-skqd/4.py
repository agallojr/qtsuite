"""
ex1
"""

# Imports
import numpy as np

from qiskit import QuantumCircuit
from qiskit.circuit.library import PauliEvolutionGate
from qiskit.quantum_info import SparsePauliOp
from qiskit.synthesis import LieTrotter
from qiskit.transpiler import generate_preset_pass_manager
from qiskit_aer import AerSimulator
from qiskit_aer.primitives import SamplerV2

from qc_grader.challenges.qdc_2025 import qdc25_lab4
from qiskit_addon_sqd.counts import counts_to_arrays
from qiskit_addon_sqd.qubit import sort_and_remove_duplicates, solve_qubit

import skqd_helpers

def perturbed_tfim_hamiltonian(num_qubits: int, J: float, hx: float, hz: float) -> SparsePauliOp:
    """Builds the perturbed transverse-field Ising model Hamiltonian as a `SparsePauliOp`.

    Args:
        num_qubits: Number of qubits
        J: Exchange energy
        hx: Field strength in x-direction
        hz: Field strength in z-direction

    Returns:
        Hamiltonian as a SparsePauliOp following Qiskit's endian convention.
    """
    pauli_list = []
    coeff_list = []

    # ZZ terms
    for j in range(num_qubits - 1):
        # Build Pauli string with Z at positions j and j+1
        pauli_str = ['I'] * num_qubits
        pauli_str[j] = 'Z'
        pauli_str[j + 1] = 'Z'
        pauli_list.append(''.join(pauli_str))
        coeff_list.append(-J)

    # X terms
    for j in range(num_qubits):
        # Build Pauli string with X at position j
        pauli_str = ['I'] * num_qubits
        pauli_str[j] = 'X'
        pauli_list.append(''.join(pauli_str))
        coeff_list.append(-hx)

    # Z term
    pauli_str = ['I'] * num_qubits
    pauli_str[0] = 'Z'
    pauli_list.append(''.join(pauli_str))
    coeff_list.append(-hz)

    return SparsePauliOp(pauli_list, coeffs=np.array(coeff_list, dtype=np.complex64))


def construct_krylov_circuits(
        H_spo: SparsePauliOp, psi: QuantumCircuit, r: int, num_trotter_steps: int, dt: float
    ) -> list[QuantumCircuit]:
    """Build r Krylov circuits using time evolution generated by SparsePauliOp.

    Args:
        H_spo: Hamiltonian as SparsePauliOp
        psi: Initial state to time evolve
        r: number of Krylov basis states (i.e., Krylov dimension)
        num_trotter_steps: Number of Trotter steps per evolution gate
        dt: time step

    Returns:
        List of QuantumCircuits representing each Krylov state
    """
    _circuits = []

    for k in range(r):
        qc = psi.copy()
        for _ in range(k):
            evolution_gate = PauliEvolutionGate(
                H_spo,
                time=dt,
                synthesis=LieTrotter(reps=num_trotter_steps)
            )
            qc.append(evolution_gate, qc.qubits)

        _circuits.append(qc)

    return _circuits


def siam_hamiltonian_momentum(
    num_orbs: int,
    hopping: float,
    onsite: float,
    hybridization: float,
    chemical_potential: float,
) -> tuple[np.ndarray, np.ndarray]:

    h1e, h2e = skqd_helpers.siam_hamiltonian(
        num_orbs, hopping, onsite, hybridization, chemical_potential
    )
    
    orbital_rotation = skqd_helpers.momentum_basis(num_orbs)
    
    # Transpose orbital_rotation to get proper U.H @ H @ U transformation
    h1e_momentum, h2e_momentum = skqd_helpers.rotated(h1e, h2e, orbital_rotation.T)
    
    return h1e_momentum, h2e_momentum


if __name__ == "__main__":
    NUM_ORBS = 10
    HOPPING = 1.0
    ONSITE = 5
    HYBRIDIZATION = 1.0
    CHEMICAL_POTENTIAL = -0.5 * ONSITE

    # grader order:                    NUM_ORBS, HYBRIDIZATION, HOPPING, ONSITE, CHEMICAL_POTENTIAL

    # 10, 1, 1, 5, chem
    # 10, 1, 1, 5, chem

    result = siam_hamiltonian_momentum(NUM_ORBS, HYBRIDIZATION, HOPPING, ONSITE, CHEMICAL_POTENTIAL)

    # print(f"0: {result[0].tolist()}")
    # print("----------------")
    # print(f"1: {result[1].tolist()}")
    qdc25_lab4.grade_lab4_ex4(siam_hamiltonian_momentum)
