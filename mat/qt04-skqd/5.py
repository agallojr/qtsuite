"""
ex1
"""

# Imports
import numpy as np
import scipy


from qiskit import QuantumCircuit, QuantumRegister
from qiskit.circuit.library import PauliEvolutionGate
from qiskit.quantum_info import SparsePauliOp
from qiskit.synthesis import LieTrotter
from qiskit.transpiler import generate_preset_pass_manager
from qiskit_aer import AerSimulator
from qiskit_aer.primitives import SamplerV2

from qc_grader.challenges.qdc_2025 import qdc25_lab4
from qiskit_addon_sqd.counts import counts_to_arrays
from qiskit_addon_sqd.qubit import sort_and_remove_duplicates, solve_qubit

import skqd_helpers

def perturbed_tfim_hamiltonian(num_qubits: int, J: float, hx: float, hz: float) -> SparsePauliOp:
    """Builds the perturbed transverse-field Ising model Hamiltonian as a `SparsePauliOp`.

    Args:
        num_qubits: Number of qubits
        J: Exchange energy
        hx: Field strength in x-direction
        hz: Field strength in z-direction

    Returns:
        Hamiltonian as a SparsePauliOp following Qiskit's endian convention.
    """
    pauli_list = []
    coeff_list = []

    # ZZ terms
    for j in range(num_qubits - 1):
        # Build Pauli string with Z at positions j and j+1
        pauli_str = ['I'] * num_qubits
        pauli_str[j] = 'Z'
        pauli_str[j + 1] = 'Z'
        pauli_list.append(''.join(pauli_str))
        coeff_list.append(-J)

    # X terms
    for j in range(num_qubits):
        # Build Pauli string with X at position j
        pauli_str = ['I'] * num_qubits
        pauli_str[j] = 'X'
        pauli_list.append(''.join(pauli_str))
        coeff_list.append(-hx)

    # Z term
    pauli_str = ['I'] * num_qubits
    pauli_str[0] = 'Z'
    pauli_list.append(''.join(pauli_str))
    coeff_list.append(-hz)

    return SparsePauliOp(pauli_list, coeffs=np.array(coeff_list, dtype=np.complex64))


def construct_krylov_circuits(
        H_spo: SparsePauliOp, psi: QuantumCircuit, r: int, num_trotter_steps: int, dt: float
    ) -> list[QuantumCircuit]:
    """Build r Krylov circuits using time evolution generated by SparsePauliOp.

    Args:
        H_spo: Hamiltonian as SparsePauliOp
        psi: Initial state to time evolve
        r: number of Krylov basis states (i.e., Krylov dimension)
        num_trotter_steps: Number of Trotter steps per evolution gate
        dt: time step

    Returns:
        List of QuantumCircuits representing each Krylov state
    """
    _circuits = []

    for k in range(r):
        qc = psi.copy()
        for _ in range(k):
            evolution_gate = PauliEvolutionGate(
                H_spo,
                time=dt,
                synthesis=LieTrotter(reps=num_trotter_steps)
            )
            qc.append(evolution_gate, qc.qubits)

        _circuits.append(qc)

    return _circuits


def siam_hamiltonian_momentum(
    num_orbs: int,
    hopping: float,
    onsite: float,
    hybridization: float,
    chemical_potential: float,
) -> tuple[np.ndarray, np.ndarray]:

    h1e, h2e = skqd_helpers.siam_hamiltonian(
        num_orbs, hopping, onsite, hybridization, chemical_potential
    )
    
    orbital_rotation = skqd_helpers.momentum_basis(num_orbs)
    
    # Transpose orbital_rotation to get proper U.H @ H @ U transformation
    h1e_momentum, h2e_momentum = skqd_helpers.rotated(h1e, h2e, orbital_rotation.T)
    
    return h1e_momentum, h2e_momentum


def construct_krylov_siam(
    num_orbs:int,
    impurity_index: int,
    hamiltonian: tuple[np.ndarray, np.ndarray],
    dt: float,
    krylov_dim: int
) -> list[QuantumCircuit]:
    """Generate Krylov circuits for SIAM.

    Args:
        num_orbs: Number of spatial orbitals
        impurity_index: Index of impurity orbital
        hamiltonian: one- and two-body Hamiltonian terms
        dt: Time step
        krylov_dim: Number of Krylov basis states
    
    Returns:
        SIAM Krylov circuits.
    """
    circuits = []
    
    # SIAM requires 2*num_orbs qubits (spin up and spin down)
    num_qubits = 2 * num_orbs
    
    # Occupancy number (half-filled system)
    occ_num = num_orbs // 2
    
    # Convert h1e to unitary time evolution operator for OrbitalRotationJW
    h1e_unitary = scipy.linalg.expm(-1j * dt * hamiltonian[0])
    hamiltonian_unitary = (h1e_unitary, hamiltonian[1])
    
    for k in range(krylov_dim):
        # Create quantum circuit with quantum register
        qreg = QuantumRegister(num_qubits, 'q')
        qc = QuantumCircuit(qreg)
        
        # Prepare initial state using helper
        for instruction in skqd_helpers.prepare_initial_state(qreg, num_orbs, occ_num):
            qc.append(instruction)
        
        # Apply k Trotter steps for k-th Krylov state using helper
        for _ in range(k):
            for instruction in skqd_helpers.trotter_step(qreg, dt, hamiltonian_unitary, impurity_index, num_orbs):
                qc.append(instruction)
        
        circuits.append(qc)
    
    return circuits



if __name__ == "__main__":
    qdc25_lab4.grade_lab4_ex5(construct_krylov_siam, siam_hamiltonian_momentum)
