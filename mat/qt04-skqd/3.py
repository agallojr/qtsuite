"""
ex1
"""

# Imports
import numpy as np

from qiskit import QuantumCircuit
from qiskit.circuit.library import PauliEvolutionGate
from qiskit.quantum_info import SparsePauliOp
from qiskit.synthesis import LieTrotter
from qiskit.transpiler import generate_preset_pass_manager
from qiskit_aer import AerSimulator
from qiskit_aer.primitives import SamplerV2

from qc_grader.challenges.qdc_2025 import qdc25_lab4
from qiskit_addon_sqd.counts import counts_to_arrays
from qiskit_addon_sqd.qubit import sort_and_remove_duplicates, solve_qubit

import skqd_helpers

def perturbed_tfim_hamiltonian(num_qubits: int, J: float, hx: float, hz: float) -> SparsePauliOp:
    """Builds the perturbed transverse-field Ising model Hamiltonian as a `SparsePauliOp`.

    Args:
        num_qubits: Number of qubits
        J: Exchange energy
        hx: Field strength in x-direction
        hz: Field strength in z-direction

    Returns:
        Hamiltonian as a SparsePauliOp following Qiskit's endian convention.
    """
    pauli_list = []
    coeff_list = []

    # ZZ terms
    for j in range(num_qubits - 1):
        # Build Pauli string with Z at positions j and j+1
        pauli_str = ['I'] * num_qubits
        pauli_str[j] = 'Z'
        pauli_str[j + 1] = 'Z'
        pauli_list.append(''.join(pauli_str))
        coeff_list.append(-J)

    # X terms
    for j in range(num_qubits):
        # Build Pauli string with X at position j
        pauli_str = ['I'] * num_qubits
        pauli_str[j] = 'X'
        pauli_list.append(''.join(pauli_str))
        coeff_list.append(-hx)

    # Z term
    pauli_str = ['I'] * num_qubits
    pauli_str[0] = 'Z'
    pauli_list.append(''.join(pauli_str))
    coeff_list.append(-hz)

    return SparsePauliOp(pauli_list, coeffs=np.array(coeff_list, dtype=np.complex64))


def construct_krylov_circuits(
        H_spo: SparsePauliOp, psi: QuantumCircuit, r: int, num_trotter_steps: int, dt: float
    ) -> list[QuantumCircuit]:
    """Build r Krylov circuits using time evolution generated by SparsePauliOp.

    Args:
        H_spo: Hamiltonian as SparsePauliOp
        psi: Initial state to time evolve
        r: number of Krylov basis states (i.e., Krylov dimension)
        num_trotter_steps: Number of Trotter steps per evolution gate
        dt: time step

    Returns:
        List of QuantumCircuits representing each Krylov state
    """
    _circuits = []

    for k in range(r):
        qc = psi.copy()
        for _ in range(k):
            evolution_gate = PauliEvolutionGate(
                H_spo,
                time=dt,
                synthesis=LieTrotter(reps=num_trotter_steps)
            )
            qc.append(evolution_gate, qc.qubits)

        _circuits.append(qc)

    return _circuits


if __name__ == "__main__":
    # Hamiltonian parameters
    num_qubits = 12
    J = 1.0
    hx = 0.1
    hz = 0.1

    # Construct Hamiltonian
    H_spo = perturbed_tfim_hamiltonian(num_qubits, J, hx, hz)

    # Calculate an optimal dt for Trotterization using the
    # `dt_from_spectral_norm()` helper function.
    dt = skqd_helpers.dt_from_spectral_norm(H_spo)
    print(f"Helper suggested optimal dt: {dt}")

    # Specify a Krylov dimension (i.e., subspace size)
    krylov_dim = 5         # 3, 5, 7
    num_trotter_steps = 1  # Trotter steps per evolution gate

    # Construct the QuantumCircuit representing the intial state
    psi = QuantumCircuit(num_qubits)

    # Construct the Krylov circuits
    krylov_circuits = construct_krylov_circuits(
        H_spo, psi, krylov_dim, num_trotter_steps, dt
    )
    print(f"{len(krylov_circuits)} Krylov circuits")

    # Instantiate a backend
    backend = AerSimulator()

    # Add measurements to circuits
    for circuit in krylov_circuits:
        circuit.measure_all()
    
    # Transpile Krylov circuits to ISA circuits specific for the chosen backend
    pm = generate_preset_pass_manager(backend=backend)
    isa_circuits = pm.run(krylov_circuits)

    # Instantiate a `SamplerV2` to generate samples from the ISA circuits
    sampler = SamplerV2()

    # Perform classical simulation
    job = sampler.run(isa_circuits)
    
    # Retrieve results
    results = job.result()
    print(f"Sampled {len(results)} circuits")

    # Get the bitstrings (and, optionally, probabilities)
    # Collect measurement data from each circuit result
    # Combine all counts into a single dictionary
    combined_counts = {}
    for pub_result in results:
        counts = pub_result.data.meas.get_counts()
        # Merge counts into combined dict
        for bitstring, count in counts.items():
            combined_counts[bitstring] = combined_counts.get(bitstring, 0) + count
    
    # Convert counts to bitstring arrays
    bitstrings, probabilities = counts_to_arrays(combined_counts)
    print(f"Bitstrings shape: {bitstrings.shape}")
    print(f"Probabilities shape: {probabilities.shape}")

    # Sort bitstring matrix
    sorted_bitstrings = sort_and_remove_duplicates(bitstrings)

    # Calculate eigenvalues (and, optionally, eigenvectors)
    eigenvalues, eigenvectors = solve_qubit(
        hamiltonian=H_spo,
        bitstring_matrix=sorted_bitstrings
    )
    print(f"Number of eigenvalues: {len(eigenvalues)}")

    # Determine SKQD approximation to the ground state energy
    ground_state_energy = np.min(eigenvalues).real
    print(f"SKQD ground state energy: {ground_state_energy}")

    # Submit to grader
    qdc25_lab4.grade_lab4_ex3(bitstrings, H_spo)

